using System;
using System.IO;
using CryptoSQLite;
using UIKit;

namespace CryptoSQLiteSample.iOS
{
	// IMPORTANT ALL [Encrypted] COLUMNS STORED IN DATABASE AS A BLOB TYPE

    [CryptoTable("MyTasks")]
    public class Tasks
    {
        [PrimaryKey, AutoIncremental]
        public int Id { get; set; }

        [Encrypted, NotNull]
        public string Task { get; set; }

		[NotNull("Default Description")]
        public string Description { get; set; }

		[Column("PriceForTask")]
        public double? Price { get; set; }

        public bool IsDone { get; set; }
    }

	[CryptoTable("Infos")]
    internal class Info
    {
        [PrimaryKey, AutoIncremental]
        public int Id { get; set; }

        [Encrypted]
        public string SomeInfo { get; set; }

        [Encrypted]
        public double SomeValue { get; set; }

        public bool Equal(Info i)
        {
            return SomeInfo == i.SomeInfo && Math.Abs(SomeValue - i.SomeValue) < 0.000001;
        }
    }

    public partial class ViewController : UIViewController
    {
        private string fileName = "MySqlDb.db3";
        public ViewController(IntPtr handle) : base(handle)
        {
        }

        public override void ViewDidLoad()
        {
            base.ViewDidLoad();

            // ! IMPORTANT ! This function determines how to talk to a specific instance of the native SQLite3 library.
            // You can call this function in AppDelegate::FinishedLaunching() function or in AppDelegate ctor.
            SQLitePCL.Batteries_V2.Init(); // From NuGet package SQLitePCLRaw.bundle_green. 
			//OR: SQLitePCL.Batteries.Init(); // From NuGet package SQLitePCLRaw.bundle_green
			
			CryptoSQLiteConnection db = null;
            
			try
            {
                var documentsPath = Environment.GetFolderPath(Environment.SpecialFolder.Personal); // Documents folder

                var libraryPath = Path.Combine(documentsPath, "..", "Library");                    // Library folder

                var pathToDatabaseFile = Path.Combine(libraryPath, fileName);

                db = new CryptoSQLiteConnection(pathToDatabaseFile, CryptoAlgoritms.AesWith256BitsKey);

                // SETTING ENCRYPTION KEY FOR ALL TABLES IN DATABASE FILE
                var keyForDatabase = new byte[32];
                db.SetEncryptionKey(keyForDatabase);

                var specificKey = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2};
                // SITTING SPECIFIC ENCRYPTION KEY ONLY FOR TABLE 'Infos'. THIS KEY WILL BE USED ONLY IN TABLE 'Infos' FOR ENCRYPTION DATA.
                db.SetEncryptionKey<Info>(specificKey);

                db.CreateTable<Tasks>();
                db.CreateTable<Info>();

                // All Properties that have [Encrypted] attribute properties will be automatically encrypted or decrypted
                
				// Here all data in table 'Infos' will be encrypted using 'specificKey'
				db.InsertItem(new Info {SomeInfo = "Some Info 1", SomeValue = 12343.11212});    

				// In table 'Tasks' for encryption data will be used 'keyForDatabase' key, because we don't specify for table 'Tasks' cpecific encryption key
                db.InsertItem(new Tasks { Task = "Task1", Description = "Description_1", Price = 1234.41, IsDone = false });
                db.InsertItem(new Tasks { Task = "Task2", Description = "Description_2", Price = 1307.69, IsDone = true });
                db.InsertItem(new Tasks { Task = "Task3", Description = "Description_1", Price = null, IsDone = true });
                db.InsertItem(new Tasks { Task = "Task4", Description = "Description_2", Price = 1100.99, IsDone = false });
                db.InsertItem(new Tasks { Task = "Task5", Description = "Description_2", Price = 1718.99, IsDone = false });
                db.InsertItem(new Tasks { Task = "Task6", Description = "Description_3", Price = null, IsDone = true });
			

				// FIND ELEMENTS IN LINQ MANNER:

                var completedTasks = db.Find<Tasks>(t => t.IsDone);             // SQL Request will be: SELECT * FROM MyTasks WHERE (IsDone = 1)

                var notCompletedTasks = db.Find<Tasks>(t => !t.IsDone);         // SQL Request will be: SELECT * FROM MyTasks WHERE (IsDone = 0)

                var tasksWithoutPrice = db.Find<Tasks>(t => t.Price == null);   // SQL Request will be: SELECT * FROM MyTasks WHERE (Price IS NULL) 

                var tasksWithPrice = db.Find<Tasks>(t => t.Price != null);      // SQL Request will be: SELECT * FROM MyTasks WHERE (Price IS NOT NULL) 

                var completedTasksWithPriceLessThanValue = db.Find<Tasks>(t => t.IsDone && t.Price < 1400); // SQL Request will be: SELECT * FROM MyTasks WHERE ((IsDone = 1) AND (Price < 1400))

                var taskWithExplisitDescription = db.Find<Tasks>(t => t.Description == "Description_3");    // SQL Request will be: SELECT * FROM MyTasks WHERE (Description = 'Description_3')

                var exampleWithThreeRules = db.Find<Tasks>(t => t.IsDone && t.Price > 1000 && t.Price < 1300);  // SQL Request will be: SELECT * FROM MyTasks WHERE (((IsDone = 1) AND (Price > 1000)) AND (Price < 1300))


				// NOW WE CAN SPECIFY WHICH COLUMNS SHOULD BE READED FROM DATABASE
				var selectedItem = db.Select<Tasks>(t => t.IsDone, "Task" /*Property Name!*/, "Price" /*Property Name!*/);    // It will get values for only 'Task' and 'Price' properties

				// DELETE USING PREDICATES
                db.Delete<Tasks>(t => t.IsDone);    // It will removes from table all completed tasks.

                db.Delete<Tasks>(t => t.Price == null);     // Removes all tasks for which Price is not set

                db.Delete<Tasks>(t => t.Price == null || t.IsDone);

                db.Delete<Tasks>(t => t.Price < 1300 && t.Description == "Description_1");
            }
            catch (Exception ex)
            {
                var msg = ex.Message;
            }
			finally
            {
                db?.Dispose(); // Here all internal copies of Encryption Key will be removed from memory (ZeroMemory).
            }
		}

		public override void DidReceiveMemoryWarning ()
		{
			base.DidReceiveMemoryWarning ();
			// Release any cached data, images, etc that aren't in use.
		}
	}
}

